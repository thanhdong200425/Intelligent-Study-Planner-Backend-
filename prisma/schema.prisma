// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management
model User {
  id             Int     @id @default(autoincrement())
  email          String  @unique
  hashedPassword String  @map("hashed_password")
  name           String?
  avatar         String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships - all user data
  courses             Course[]
  deadlines           Deadline[]
  tasks               Task[]
  availabilityWindows AvailabilityWindow[]
  timeBlocks          TimeBlock[]
  habits              Habit[]
  habitCompletions    HabitCompletion[]
  weeklySummaries     WeeklySummary[]
  timerSessions       TimerSession[]

  @@map("users")
}

// Core academic entities
model Course {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  name      String
  color     String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  deadlines Deadline[]
  tasks     Task[]

  @@map("courses")
}

model Deadline {
  id        Int              @id @default(autoincrement())
  userId    Int              @map("user_id")
  title     String
  courseId  Int              @map("course_id")
  dueDate   DateTime         @map("due_date")
  priority  DeadlinePriority @default(MEDIUM)
  completed Boolean          @default(false)
  createdAt DateTime         @default(now()) @map("created_at")
  updatedAt DateTime         @updatedAt @map("updated_at")

  // Relationships
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
  tasks  Task[]

  @@map("deadlines")
}

model Task {
  id              Int      @id @default(autoincrement())
  userId          Int      @map("user_id")
  title           String
  courseId        Int      @map("course_id")
  type            TaskType
  estimateMinutes Int      @map("estimate_minutes")
  deadlineId      Int?     @map("deadline_id")
  completed       Boolean  @default(false)
  actualMinutes   Int?     @map("actual_minutes")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relationships
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  course     Course      @relation(fields: [courseId], references: [id], onDelete: Cascade)
  deadline   Deadline?   @relation(fields: [deadlineId], references: [id], onDelete: SetNull)
  timeBlocks TimeBlock[]

  @@map("tasks")
}

// Scheduling and time management
model AvailabilityWindow {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  dayOfWeek Int      @map("day_of_week") // 0-6 (Sunday-Saturday)
  startTime String   @map("start_time") // HH:MM format
  endTime   String   @map("end_time") // HH:MM format
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("availability_windows")
}

model TimeBlock {
  id            Int        @id @default(autoincrement())
  userId        Int        @map("user_id")
  taskId        Int?       @map("task_id")
  startTime     DateTime   @map("start_time")
  endTime       DateTime   @map("end_time")
  isBreak       Boolean    @default(false) @map("is_break")
  breakType     BreakType? @map("break_type")
  actualMinutes Int?       @map("actual_minutes")
  completed     Boolean    @default(false)
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @updatedAt @map("updated_at")

  // Relationships
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  task          Task?          @relation(fields: [taskId], references: [id], onDelete: Cascade)
  timerSessions TimerSession[]

  @@map("time_blocks")
}

// Habit tracking
model Habit {
  id            Int      @id @default(autoincrement())
  userId        Int      @map("user_id")
  name          String
  targetMinutes Int      @map("target_minutes")
  currentStreak Int      @default(0) @map("current_streak")
  longestStreak Int      @default(0) @map("longest_streak")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relationships
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  completions HabitCompletion[]

  @@map("habits")
}

model HabitCompletion {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  habitId   Int      @map("habit_id")
  date      DateTime @db.Date
  minutes   Int
  createdAt DateTime @default(now()) @map("created_at")

  // Relationships
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  habit Habit @relation(fields: [habitId], references: [id], onDelete: Cascade)

  // Ensure one completion per habit per day
  @@unique([habitId, date])
  @@map("habit_completions")
}

// Analytics and reporting
model WeeklySummary {
  id                     Int      @id @default(autoincrement())
  userId                 Int      @map("user_id")
  weekStart              DateTime @map("week_start") @db.Date
  weekEnd                DateTime @map("week_end") @db.Date
  tasksCompleted         Int      @default(0) @map("tasks_completed")
  tasksOverdue           Int      @default(0) @map("tasks_overdue")
  totalActualTime        Int      @default(0) @map("total_actual_time") // in minutes
  totalPredictedTime     Int      @default(0) @map("total_predicted_time") // in minutes
  timePerCourse          Json     @map("time_per_course") // { [courseId: string]: number }
  habitStreaks           Json     @map("habit_streaks") // { [habitId: string]: number }
  mostProductiveTimeSlot Json?    @map("most_productive_time_slot") // { day: string, timeRange: string, productivity: number }
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  // Relationships
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Ensure one summary per user per week
  @@unique([userId, weekStart])
  @@map("weekly_summaries")
}

// Timer sessions for actual time tracking
model TimerSession {
  id            Int       @id @default(autoincrement())
  userId        Int       @map("user_id")
  timeBlockId   Int       @map("time_block_id")
  startTime     DateTime  @map("start_time")
  endTime       DateTime? @map("end_time")
  isActive      Boolean   @default(true) @map("is_active")
  actualMinutes Int       @default(0) @map("actual_minutes")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relationships
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  timeBlock TimeBlock @relation(fields: [timeBlockId], references: [id], onDelete: Cascade)

  @@map("timer_sessions")
}

// Enums
enum DeadlinePriority {
  LOW
  MEDIUM
  HIGH
}

enum TaskType {
  READING
  CODING
  WRITING
  PSET
  OTHER
}

enum BreakType {
  SHORT
  LONG
}
